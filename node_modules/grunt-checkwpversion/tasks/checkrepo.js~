/*
 * grunt-checkrepo
 * https://github.com/stephenharris/grunt-checkwpversion
 *
 * Licensed under the MIT license.
 * http://www.opensource.org/licenses/MIT
 */
'use strict';


module.exports = function(grunt) {
	
	// Error handler
	function failed(message, error) {
		grunt.fail.warn(message || 'Task failed.');
		if (error) {
			grunt.verbose.error(error);
		}
	}

	// Task definition
	grunt.registerMultiTask('checkrepo', 'Checking repository state.', function () {
		var config = this.data;
		var queue = Object.keys(config);

		// Check for checks
		if (!queue.length) {
			failed('No checks requested.');
			return;
		}

		// Check for git repository
		if (exec('git status').code !== 0) {
			failed('Git repository not found.');
			return;
		}

		/**
		 * Repository checks.
		 *
		 * @type {Object}
		 */
		var checks = {
			tag: function (config) {
				var highestTag = git.getHighestTag();
				var methods = Object.keys(config);
				var result = true;

				methods.forEach(function (method) {
					if (method === 'valid') {
						if (semver.valid(config.valid)) {
							grunt.verbose.ok('Version "' + String(config.valid).cyan + '" is a valid semantic version.');
						} else {
							failed('Version "' + config.valid + '" is not a valid semantic version.');
							result = false;
						}
					} else {
						if (semver[method](highestTag, config[method])) {
							grunt.verbose.ok('Highest tag "' + String(highestTag).cyan + '" is ' + method + ' "' + String(config[method]).cyan+ '".');
						} else {
							failed('Highest tag "' + highestTag + '" is not ' + method + ' "' + config[method] + '".');
							result = false;
						}
					}
				});

				return result;
			},
			tagged: function (flag) {
				if (git.isTagged() === flag) {
					grunt.verbose.ok('Current commit is' + (flag ? '' : ' not') + ' tagged.');
					return true;
				} else {
					failed('Current commit is' + (flag ? ' not' : '') + ' tagged.');
					return false;
				}
			},
			clean: function (flag) {
				if (git.isClean() === flag) {
					grunt.verbose.ok('There are' + (flag ? ' no' : '') + ' unstaged changes.');
					return true;
				} else {
					failed('There are' + (flag ? '' : ' no') + ' unstaged changes.');
					return false;
				}
			}
		};

		// Run checks
		for (var i = 0; i < queue.length; i++) {
			if (!checks[queue[i]](config[queue[i]])) {
				break;
			}
		}

		var plugin_file = build_dir + slug+".php";
		var readme_file = build_dir + "readme.txt";

		//SVN user/url
		var svnuser = options.svn_user || answers.svn_username; 
		var svnurl = options.svn_url.replace( '{plugin-slug}', slug );

		//Try to find readme
		if ( !grunt.file.exists(readme_file) ) {
			grunt.fail.warn('readme.txt file not not found.');
		}

		//Try to find plug-in file
		if ( !grunt.file.exists(plugin_file) ) {
			grunt.fail.warn( plugin_file+' file not not found.');
		}

		//Get versions:
		var readme = grunt.file.read(readme_file);
		var readmeVersion = readme.match( new RegExp("^Stable tag:\\s*(\\S+)","im") );
		var plugin = grunt.file.read(plugin_file);
		var pluginVersion = plugin.match( new RegExp("^Version:\\s*(\\S+)","im") );

		//Check versions
		if(  projectVersionCompare( pluginVersion[1],  readmeVersion[1] )  !== 0 ){
			grunt.log.warn( "Readme.txt version: " + readmeVersion[1] );
			grunt.log.warn( slug+".php version: " + pluginVersion[1] );
			grunt.fail.warn( 'Versions do not match:');	
		}
	});
};
